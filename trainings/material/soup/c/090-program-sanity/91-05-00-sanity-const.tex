\subsection{Correctness --- \texttt{const}}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Non-Modifiable Memory (1)}

  % see Material/C-Advanced/Code/const/string-blah.c

  \textbf{Did you know the difference?}

  \begin{block}{}
\begin{verbatim}
void f(void)
{
    char str[] = "blah";
    str[0] = 'x';
}
\end{verbatim}
  \end{block}

  \begin{block}{}
\begin{verbatim}
void f(void)
{
    char *str = "blah";
    str[0] = 'x';
}
\end{verbatim}
  \end{block}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}
  \frametitle{Non-Modifiable Memory (2)}

  \begin{columns}[t]

    \begin{column}{.36\textwidth}

      \texttt{char str[] = "blah";}

      \begin{block}{}
        \includegraphics[height=0.3\textheight]{91-05-00-sanity-const-memory-stack.png}
      \end{block}

      \begin{itemize}
      \item Array initialization
      \item Allocated on the \textit{stack}, at \textit{runtime}
      \item $\to$ \textit{writable}
      \end{itemize}

    \end{column}

    \begin{column}{.54\textwidth}

      \texttt{char *str = "blah";}

      \begin{block}{}
        \includegraphics[height=0.3\textheight]{91-05-00-sanity-const-memory-rodata.png}
      \end{block}

      \begin{itemize}
      \item Allocated in \textit{read-only memory}, at
        \textit{compilation time}
      \item Pointer setup \textit{at runtime}, to point there
      \item $\to$ \alert{\textit{not writable}}
      \end{itemize}

    \end{column}

  \end{columns}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{The \texttt{const} Keyword (1)}

  So there is already the concept of read-only data ...

  \begin{itemize}
  \item Sadly compilers generally issue no warnings
  \item (On Linux) Not an error, only on-demand duplication of a
    \textit{shared} read-only memory page
  \item $\to$ \textit{expensive}
  \item Unintended in most cases
  \end{itemize}

  \begin{block}{}
\begin{verbatim}
$ gcc -Wwrite-strings ...
warning: initialization discards ‘const’ qualifier from 
   pointer target type
\end{verbatim}
  \end{block}

  \textbf{A-ha:} ``const'' qualifier!

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{The \texttt{const} Keyword (2)}

  \begin{block}{}
\begin{verbatim}
warning: initialization discards ‘const’ qualifier from 
   pointer target type
\end{verbatim}
  \end{block}

  \begin{itemize}
  \item \texttt{char *str = "blah";}
  \item Obviously (no surprise) the compiler knows that
    \texttt{"blah"} is in read-only memory
  \item $\to$ String literals are \texttt{const char *}
  \end{itemize}

  \begin{block}{}
\begin{verbatim}
const char *str = "blah";
\end{verbatim}
  \end{block}

  \textbf{Consequences:}

  \begin{itemize}
  \item \texttt{str} cannot be written to
  \item $\to$ Code has to be fixed until compiler is happy
  \item $\to$ \textcolor{green}{Correctness} with minimal effort
  \end{itemize}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{\texttt{const} Variables}

  Getting rid of the preprocessor (good idea) ...

  \begin{block}{}
\begin{verbatim}
const int MAX_BUCKETS = 64;
\end{verbatim}
  \end{block}

  ... is the same, compiler-wise, as ...

  \begin{block}{}
\begin{verbatim}
#define MAX_BUCKETS 64
\end{verbatim}
  \end{block}

  \textbf{Additional benefits ...}

  \begin{itemize}
  \item \texttt{MAX\_BUCKETS} has a type
  \item Not a stupid string substitution, but a regular C identifier
  \item ``unused'' warnings
  \end{itemize}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{\texttt{const} Parameters (1)}

  \begin{block}{}
\begin{verbatim}
int sum(int *begin, int *end);
\end{verbatim}
  \end{block}

  \textbf{Reading this declaration, we assume the following:}

  \begin{itemize}
  \item It builds a \texttt{sum} 
  \item It returns the result
  \item It operates on a range \texttt{[begin, end)}
  \item It does not modify the input data
  \end{itemize}
  
  \textbf{Ambiguity alert:}

  \begin{itemize}
  \item We can say nothing of the above for sure
  \item ... but we can help with the last item
  \end{itemize}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{\texttt{const} Parameters (2)}

  \begin{block}{}
\begin{verbatim}
int sum(const int *begin, const int *end);
\end{verbatim}
  \end{block}

  \textbf{Now we can say one thing for sure:}

  \begin{itemize}
  \item It does not modify the input data
  \end{itemize}
  
  \textbf{Consequences:}

  \begin{itemize}
  \item \texttt{sum()} has to modified
  \item Not a big deal when only a few lines involved
  \item Can be a problem when code is large and complex
  \item $\to$ \textbf{``\texttt{const} pollution''}
  \end{itemize}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Pointers, Pointers, Pointers ... (1)}

  \textbf{What's known so far:}

  \begin{itemize}
  \item \texttt{const} can be applied to scalar types
  \item \texttt{const} can be applied to \texttt{struct} types (we
    don't know this, but it's a logical consequence)
  \item \texttt{const}, applied to pointers, keeps me from modifying
    what they point to
  \end{itemize}

  \begin{block}{}
\begin{verbatim}
const int i;
int const j; /* same! */
const int *pi = &i;
int const *pj = &j;
\end{verbatim}
  \end{block}

  \begin{block}{}
    \includegraphics[width=0.3\textwidth]{91-05-00-sanity-const--c-p-nc}
  \end{block}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Pointers, Pointers, Pointers ... (2)}

  \textbf{Mixing ...}

  \begin{block}{}
\begin{verbatim}
int const i = 42;
int *pi = &i;
\end{verbatim}
  \end{block}

  \begin{block}{}
\begin{verbatim}
warning: initialization discards ‘const’ qualifier 
  from pointer target type
\end{verbatim}
  \end{block}

  \begin{itemize}
  \item \texttt{pi} does not promise to \textit{not modify} the value
    it points to
  \item Pointee is \textit{read-only}
  \item Sadly this can only be a warning for historical reasons
  \end{itemize}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Pointers, Pointers, Pointers ... (3)}

  \textbf{So, given that ...}

  \begin{block}{}
\begin{verbatim}
int const i;
\end{verbatim}
  \end{block}

  ... is a read-only variable, ...

  \begin{block}{}
\begin{verbatim}
int * const pi;
\end{verbatim}
  \end{block}

  ... is a read-only variable:

  \begin{itemize}
  \item A pointer that cannot be modified
  \item But can be used to modify what it points to (it's an
    \texttt{int}, not an \texttt{int const})
  \end{itemize}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Pointers, Pointers, Pointers ... (4)}

  \begin{block}{}
\begin{verbatim}
int * const pi;
/* error: assignment of read-only variable ‘pi’ */
pi = NULL;
/* ok, compiles */
*pi = 42;
\end{verbatim}
  \end{block}

  \begin{block}{}
    \includegraphics[width=0.3\textwidth]{91-05-00-sanity-const--nc-p-c}
  \end{block}

  \textit{But is this correct?}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Pointers, Pointers, Pointers ... (5)}

  \textbf{So what's this?}

  \begin{block}{}
\begin{verbatim}
int i = 42
int const * const pi = &i;

/* error: assignment of read-only variable ‘pi’ */
pi = NULL;

/* error: assignment of read-only location ‘*pi’ */
*pi = 42;
\end{verbatim}
  \end{block}

  \begin{block}{}
    \includegraphics[width=0.3\textwidth]{91-05-00-sanity-const--c-p-c}
  \end{block}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Pointers, Pointers, Pointers ... (6)}

  \textbf{How about pointers that point to pointers?}

  \begin{block}{}
\begin{verbatim}
int i = 42;
int *pi = &i;
int **ppi = &pi;

**ppi = 7;
*ppi = NULL;
\end{verbatim}
  \end{block}

  \begin{block}{}
    \includegraphics[width=0.5\textwidth]{91-05-00-sanity-const--nc-p-nc-p-nc}
  \end{block}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Pointers, Pointers, Pointers ... (7)}

  \textbf{How about pointers that point to pointers that point to
    \texttt{const}?} (Gosh)

  \begin{block}{}
\begin{verbatim}
int const i = 42;
int const *pi = &i;
int const **ppi = &pi;

ppi = NULL;
*ppi = NULL;
/* error: assignment of read-only location ‘**ppi’ */
**ppi = 7;
\end{verbatim}
  \end{block}

  \begin{block}{}
    \includegraphics[width=0.5\textwidth]{91-05-00-sanity-const--pppppp}
  \end{block}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Pointers, Pointers, Pointers ... (8)}

  \textbf{How about pointers that point to non-modifiable pointers
    that point to \texttt{const}?}

  \begin{block}{}
\begin{verbatim}
int const i = 42;
int const * const pi = &i;
int const * const *ppi = &pi;

ppi = NULL;
/* error: assignment of read-only location ‘*ppi’ */
*ppi = NULL;
/* error: assignment of read-only location ‘**ppi’ */
**ppi = 7;
\end{verbatim}
  \end{block}

  \begin{block}{}
    \includegraphics[width=0.5\textwidth]{91-05-00-sanity-const--ppppppccccppppp}
  \end{block}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}
  \frametitle{Pointers, Pointers, Pointers ... (9)}

  \textbf{How about ...?} (To be continued)

\end{frame}

