\subsection{Explict Type Safety}

% --------------------------------------------------------------------
\begin{frame}
  \frametitle{Integer Types Are Ambiguous}

  \textbf{Using integers as parameters and return types obfuscates
    code}

  \begin{itemize}
  \item Conversions happen automatically, without any notice by the
    compiler
  \item Worse: their semantics is not always clear
    \begin{itemize}
    \item \texttt{size\_t} helps to a certain extent
    \end{itemize}
  \item Even more worse:
    \begin{itemize}
    \item Mixing integers with different semantics
    \item Changing semantics $\to$ \textbf{\textit{no}} help by
      compiler
    \end{itemize}
  \end{itemize}

  \textbf{Example:} error handling ...

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Example: Ambiguous Error Schemes (1)}

  \textbf{Returns a ``signed size type'': negative on error, size
    written otherwise} (Unix tradition: waste half of the domain for
  an occasional -1):

  \begin{block}{}
\begin{verbatim}
ssize_t send_frame(
  struct protocol_engine *eng,
  const struct frame *f);
\end{verbatim}
  \end{block}

  \textbf{Always returns a valid sum:}

  \begin{block}{}
\begin{verbatim}
int sum(const int *begin, const int *end);
\end{verbatim}
  \end{block}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Example: Ambiguous Error Schemes (2)}

  \begin{block}{Automatic Conversion Massacre}
\begin{verbatim}
unsigned int send_sum(
  struct protocol_engine *engine,
  const int *begin, const int *end)
{
  struct frame f;
  int retval = sum(begin, end);

  f.type = INT32;
  f.v_int32 = retval;
  retval = send_frame(engine, &f);

  return retval;
}
\end{verbatim}
  \end{block}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}
  \frametitle{Example: Ambiguous Error Schemes (3)}

  \textbf{What are we trying to accomplish?}

  \begin{itemize}
  \item \texttt{int sum()}: ok; sum of integers is an integer
    \begin{itemize}
    \item Should think of overflow (gosh)
    \end{itemize}
  \item \texttt{ssize\_t send\_frame()}: ok, but uses weird Unix style
    error reporting.
  \item \texttt{unsigned int send\_sum()}: combines these in a
    spectacular way, and returns an application defined error number
    (0 for ok).
  \end{itemize}

  Imagine for a moment that there is one programmer who is able to
  code such crap ...

  \begin{itemize}
  \item Compiler happily converts between all these different integer
    types
  \item $\to$ Hell will break loose sooner or later
  \end{itemize}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Artificial Integer Type safety}

  \begin{block}{Passing \texttt{struct} By-Value}
\begin{verbatim}
struct point
{
  int x, y;
};
struct point addpoints(struct point lhs, struct point rhs);
\end{verbatim}
  \end{block}

  \textbf{\texttt{struct} assignment only possible on \textit{equally}
    typed values}

  \begin{itemize}
  \item Mixing impossible
  \item Why not wrap our integer error codes in \texttt{struct}s of
    adequate type?
  \end{itemize}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}
  \frametitle{Error Schemes, Revisited}

  \textbf{What was our problem?}

  \begin{itemize}
  \item Unix system calls have that weird ``-1 on failure, examine
    global \texttt{errno} variable if so'' scheme
    \begin{itemize}
    \item Valid \texttt{errno} errors are always \textgreater 0
    \end{itemize}
  \item Application-defined \texttt{unsigned int} errors otherwise
  \item Mixing is prevented only by coding \textit{very} carefully
  \end{itemize}

  \textbf{Proposed solution}: two dedicated error types ...

  \begin{itemize}
  \item \texttt{struct unix\_error}, encapsulating a Unix error
  \item \texttt{struct app\_error}, encapsulating the application's
    own error values
  \end{itemize}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Error Schemes: Encapsulating Unix Details}

  \begin{block}{Sketch: Definition of \texttt{unix\_error}}
\begin{verbatim}
struct unix_error
{
    int errno;
};
static inline struct unix_error unix_error_create(int errno)
{
    struct unix_error e;
    e.errno = errno;
    return e;
}
static inline int unix_error_ok(struct unix_error e)
{
    return e.errno == 0;
}
\end{verbatim}
  \end{block}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Error Schemes: Using Encapsulated Stuff}

  \begin{block}{Sketch: Usage of Type Safe Errors}
\begin{verbatim}
struct app_error send_sum(
  struct protocol_engine *engine,
  const int *begin, const int *end)
{
  struct unix_error uerr;
  ...
  uerr = send_frame(engine, &f);
  if (!unix_error_ok(uerr))
      return app_error_create(APP_OS_ERROR);
  ...
}
\end{verbatim}
  \end{block}

\end{frame}

% --------------------------------------------------------------------
\begin{frame}
  \frametitle{Wrap-Up: Artificial Type Safety}

  \textbf{Good news:}

  \begin{itemize}
  \item It is possible to write entirely type safe code in C
  \item Using the right measures (inlining, small structs), no
    performance impact
  \item Greatly enhances maintainability
  \end{itemize}

  \textbf{Bad news:}

  \begin{itemize}
  \item A lot of explicit typing
  \item C++ can do the same with overloading and much less typing
  \end{itemize}

\end{frame}
